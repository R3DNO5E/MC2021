# Linuxシステムプログラミング入門 事前学習#4.4 execveシステムコールの使い方
ここでは，`execve`システムコールの使い方について説明します．
## プロトタイプ
ライブラリ関数のプロトタイプは以下のようになっています．
```c
int execve(const char *pathname, char *const argv[],
                  char *const envp[]);
```
## 動作
`pathname`に指定したファイルを実行します．このとき，`execve`システムコールを呼んだプロセスが書き換えられてその実行ファイルのものに置き換えられます．つまり，誤解を恐れずに言うと，自身のプロセスがその実行ファイルを実行したときのプロセスになる，ということです．
### 実行ファイルのパス
実行ファイルのパスは相対パスでも絶対パスでも構いません．シェルとは違い実行ファイルの検索は実行しないので，実行ファイル名だけではうまくいきません．たとえば，`./hello`も`/usr/bin/bash`も許容されますが，`bash`は受け入れられません．
### コマンドライン引数
`argv`に指定したコマンドライン引数が使われます．通常，第一引数には実行ファイルのパスを指定します．`./hello`を実行する時は第一引数も`./hello`となります．詳細な利用法は引数の項で述べます．
### 環境変数
`envp`に指定した環境変数が使われます．環境変数は今回利用しないので，これ以上の詳細については述べません．
### プロセスID
新しいプロセスが作成されることなどはないので，プロセスIDは変化しません．
### ファイルディスクリプタ
開いているファイルディスクリプタは引き継がれます．
### メモリ
現在のプロセスのメモリは全て破棄され，新しいプロセスのものに置き換わります．
## 引数
`pathname`には実行するファイルのパスを絶対パスまたは相対パスの文字列で指定します．
`argv`には，使用するコマンドライン引数の文字列のポインタの配列を指定します．配列の最後にはNULLを指定します．たとえば，`char *s[] = {"ls", "/", NULL}`は正しい形式の引数です．
`envp`にも，`argv`と同様の形式で環境変数を指定します．今回はとくに利用しなくても大丈夫なので，NULLのみからなる配列を指定します．
## 返り値
成功した場合，このシステムコールを実行することによって現在のプロセスは書き換えられてしまうので，この関数は返りません．失敗した場合，`-1`が返ります．
## 代表的な使用方法
必要なファイルをインクルードします．
```c
#include <unistd.h>
```
`argv`と`envp`引数を準備します．
```c
char* path = "/usr/bin/ls"
char* arg[] = {path,"/",NULL};
char* env[] = {NULL};
```
`execve`システムコールを実行します．
```c
execve(path,arg,env);
```
## 例
以下のプログラムは指定したファイルを実行します．
```c
#include <unistd.h>
#include <stdio.h>

#define FILE_PATH "/usr/bin/id"

int main(){
    char* path = FILE_PATH;
    char* arg[] = {path,NULL};
    char* env[] = {NULL};
    execve(path,arg,env);
    puts("execve failed!\n");
}
```
