# Linuxシステムプログラミング入門 事前学習#2 Linuxの基本的な機能
## 概要
今回は，Linuxの数多くの機能のうち，この講義で使用するものについて説明します．
## ユーザ
### 概要
Linuxでは，複数のユーザを扱うことができます．ユーザと，後述するグループによって，アクセスできるファイルや，利用できるOSの機能が決まります．
### ユーザID
ユーザには，それぞれユーザID，略してUIDとよばれる番号が割り当てられています．ユーザIDは0以上の整数です．多くの場合，ユーザをプログラムで扱う場合にはユーザ名ではなくユーザIDを利用します．
### rootユーザ
Linuxが動作するコンピュータ上ごとに，ただ1つ，rootユーザと呼ばれる特別なユーザがあります．このユーザの特別な点は，システムのすべての操作を行う権限があることです．ファイルのアクセスやOSの機能の利用ではOSによって権限の確認が行われますが，すべての場合で操作が許可されます．先述したユーザIDに関して，rootユーザに割り当てられるユーザIDはほとんどの場合`0`です．類似のものとして，Windowsには`Administrator`ユーザが存在します．
### 一般ユーザ
先述したrootユーザ以外のユーザを，すべて一般ユーザと呼びます．一般ユーザがアクセスできるファイルやOSの機能はOSの権限管理機能によって制限されています．ファイルへのアクセスに関しては，ファイルの項で述べます．他のユーザに影響が大きいOSの機能は利用できないものが多いです．
### 実習
以下のコマンドを実行してみます．
```
$ id
```
実行結果は，環境によって異なりますが，概ね以下のような形式になっていると思います．
```
uid=1000(minicamp) gid=1000(minicamp) groups=1000(minicamp),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare)
```
この場合，`uid=1000(minicamp)`というところから，いま使用しているユーザのUIDは`1000`で，ユーザ名は`minicamp`であることを読みよることができます．
以下のコマンドでもユーザ名を確認することができます．
```
$ whoami
```
ユーザ名のみが表示されます．
```
minicamp
```
`sudo`コマンドを利用すると，ほかのコマンドをrootユーザとして実行することができます．試してみましょう．
```
$ sudo whoami
```
以下のようにパスワード尋ねられたら，現在使用しているユーザのパスワードを入力しましょう．ここで入力した文字はターミナルに表示されませんが，これはセキュリティのための理由で，入力は正しく行われているのでそのまま入力します．パスワードを入力したら`Enter`キーを押下します．
```
[sudo] password for minicamp:
```
すると以下のように出力されます．
```
root
```
これは，`whoami`コマンドをrootユーザで実行したことを意味しています．
次に，以下のコマンドを実行してみましょう．
```
$ cat /etc/passwd
```
たくさんの文字が出力されたと思います．これは，`/etc/passwd`というファイルの内容を出力するコマンドです．このファイルには，ユーザに関する情報が記録されています．
同様に，`/etc/shadow`というファイルを見てみましょう．
```
$ cat /etc/shadow
```
すると，以下のように表示されると思います．
```
-bash: /etc/shadow: Permission denied
```
これは，一般ユーザは`/etc/shadow`というファイルにアクセスする権限がないため，エラーが発生していることを意味します．このファイルにはユーザのパスワードが記録されているため，一般のユーザはアクセスできないように設定されています．
先ほど利用した`sudo`コマンドを再び利用して，同じように`/etc/shadow`の内容を見てみましょう．
```
$ sudo cat /etc/shadow
```
今度は，たくさんの文字列が表示されたと思います．これは，rootユーザはすべてのファイルへアクセスする権限があるため，正常にアクセスできたことを示します．
## グループ
### 概要
Linuxでは，複数のユーザが属するグループを扱うことができます．先述したユーザに加えて，操作するユーザの属するグループの権限によって，ファイルへのアクセスを許可することができます．1つのユーザは複数のグループに属することができます．
### グループID
ユーザの場合と同じように，グループも0以上の整数のIDを割り当てられています．省略してGIDと呼ばれます．ユーザIDのときと同じように，プログラムはグループをこのGIDによって扱うことが多いです．
### 実習
先ほどと同様に，以下のコマンドを実行してみます．
```
$ id
```
結果は，環境によって変わりますが，概ね以下のような形式になっていると思います．
```
uid=1000(minicamp) gid=1000(minicamp) groups=1000(minicamp),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare)
```
`gid=`から始まるところに注目してみましょう．`,`で区切られた複数のグループが表示されています．これは，今現在しているユーザがこれらのグループに所属していることを示します．たとえば，`minicamp`というグループに所属していて，このグループのグループIDは`1000`です．また，`sudo`というグループに所属していて，このグループのグループIDは`27`です．
実は，このsudoというグループに属しているユーザだけが，先ほどユーザの実習で用いたsudoコマンドを利用することができます．
`groups`というコマンドを用いても，所属しているグループを調べることができます．
```
$ grups
```
このように表示されます．さきほどと同じグループが表示されていることが分かります．
```
minicamp adm cdrom sudo dip plugdev lpadmin lxd sambashare
```
## SELinux
### ユーザとグループによる権限管理の問題点
これまで，ユーザとグループによる権限について学んできました．これらは有用ですが，充分ではない部分があります．それは許可する操作を限定することです．OSの一般ユーザには許可されていない機能を利用するとき，ユーザとグループによる権限管理だと，rootユーザを利用するしかありませんでした．その他にも，ファイルへのアクセス制御でも，グループでは不十分な場合がありました．
### rootユーザの危険性
rootユーザはすべての操作を行うことができるため，何らかのセキュリティ上の問題によってrootユーザを悪意ある人に操作されてしまうと，システム全体をその人に掌握されていまいます．つまり，rootユーザは強力すぎるため，扱いにはたいへん気を遣うものです．
### 解決策として用意されたSELinux
以上のような問題点を解決するため，伝統的なユーザとグループによる権限管理に加えて，SELinuxという機能が用意されました．これは，従来rootユーザのみが持っていた様々な特権のそれぞれに名前を付けてユーザやプログラムに分割して付与することで，rootユーザを使わずにOSの機能を利用したり，プログラムやユーザがアクセスできるファイルをより詳細に制御する機能です．
### SELinuxの利用
これはセキュリティ上有用な機能ですが，おそらくその複雑さと比較的新しい機能であることが原因で，利用されていない場合もあります．今回の講義では，この機能はLinux初学者には扱いにくいと考え，解説は別の機会に譲ることとします．
## ファイル
### 概要
ファイルは，Linux上で様々な情報を整理して扱うための機能です．パスにより，たくさんあるファイルの中から1つのファイルやディレクトリを指定します．
### ルートディレクトリ
Linuxは，ただ1つのルートディレクトリを持ちます．これは，`/`というパスで表されるディレクトリです．HDDやSSD，CDやDVD，USBメモリなどの記憶装置のファイルは，このルートディレクトリの中のある場所に配置されています．
たとえば，私の持っているUSBメモリの１つの内容は，`/media/shinku/96DB-A397/`という場所を通じて読み書きすることができます．
これは，記憶装置ごとに別の場所を考えるWindowsのファイルの概念とは大きく異なります．
### マウント
記憶装置の中に保存されているファイルを，Linuxのファイル構造の中のどこかのディレクトリを通じて読み書きできるように，あるパスを割り当てることを，「マウントする」と言います．
上に挙げた例では，USBメモリの内容は`/media/shinku/96DB-A397/`というパスにマウントされているわけです．また，LinuxをインストールしたHDDやSSDなどの記憶装置の中のファイルには`/var`や`/etc`などのパスでアクセスできますが，これは`/`というパスにSSDやHDDの内容がマウントされているためです．一部のシステムでは，`/home`というディレクトリの内容を別の記憶装置に記録するように設定されていますが，これはその記憶装置の内容を`/home`にマウントしているということです．
### 「普通の」ファイル
上に述べたように，HDDやSSDなどの記憶装置上に記録されたファイルは，ルートディレクトリの中のどこかのディレクトリにマウントされ，その場所を通じて読み書きすることができます．OSに対して，パスを指定し，読み書きなどの命令を出すことで，実際の記憶装置の読み書きがなされます．
### 特別なファイル
ファイルの中で，いくつかの種類のファイルは記憶装置に書き込まれた通常のファイルではありません．
たとえば，`/proc/cpuinfo`というファイルがあります．このファイルを読み出そうとOSに対して読み出し命令を出すと，OSは，記憶装置の中から対応するファイルを探すのではなく，現在使用しているコンピュータのCPUの情報を返します．
このように，記憶装置に記録されたファイルではない，OSとやりとりをするためのファイルが何種類か存在します．これらの特別なファイルも，記憶装置に配置されているファイルとまったく同様の方法で読み書きができますが，これらは記憶装置上にあるのではなく，OSは記憶装置にアクセスする代わりに，パスに対応する情報をOSから取得・設定する，一種の通信のようなものであることに注意してください．
### アクセス権限
すべてのファイルとディレクトリには，ファイルの所有ユーザ・ファイルの所有グループが設定されています．ファイルに設定できる権限には，読み出し・書き込み・ファイルの実行の3つがあります．これらを用いて，すべてのファイルやディレクトリそれぞれに対し，所有ユーザ・所有グループ・その他のユーザに対して，読み出し，書き込み，ファイルの実行という3つの権限のうちいくつかが設定されています．
あるユーザがファイルに対して操作をしようとしたとき，適用される権限は以下のようなルールに従います．
* そのユーザがファイルの所有ユーザである場合，所有ユーザに対する権限が適用されます
* そのユーザがファイルの所有ユーザではなくそのファイルの所有グループに属する場合，所有グループに対する権限が適用されます
* そのユーザがファイルの所有ユーザではなくそのファイルの所有グループにも属しない場合，その他のユーザに対する権限が適用されます

ここで，ファイルの所有ユーザである場合は所有グループとその他のユーザに対する権限設定は無視され，そのユーザがファイルの所有ユーザではなくそのファイルの所有グループに属する場合は所有ユーザとその他のユーザに対する権限設定に対する権限設定は無視されるということに注意してください．
ファイルの権限設定は，パーミッションと呼ばれることがあります．
### 実習
アクセス権限の確認，設定を試してみます．
まず，作業用のディレクトリを作成し，カレントディレクトリを変更します．
```
$ mkdir perm
$ cd perm
```
空のファイルを作成します．`touch`コマンドはファイルの変更日時を変更するコマンドですが，空のファイルを作成するためによく利用されます．
```
$ touch file1
```
ファイル一覧を確認します．`file1`というファイルができたことを確認します．
```
$ ls
```
このファイルのパーミッションを確認してみます．
```
$ls -l
```
ユーザやグループの名前は異なりますが，概ね以下のように表示されると思います．
```
total 0
-rw-rw-r-- 1 minicamp minicamp 0 Oct 24 19:45 file1
```
出力の見方について説明します．出力は空白区切りで以下のような形式になっています．
```
[パーミッション] [ハードリンクの数] [所有ユーザ名] [所有グループ名] [ファイルサイズ] [更新日時] [ファイル名]
```
今回の場合は，それぞれの項目の値は以下です．

|項目名|値|
|---|---|
|パーミッション|`-rw-rw-r--`|
|ハードリンクの数|`1`|
|所有ユーザ名|`minicamp`|
|所有グループ名|`minicamp`|
|ファイルサイズ|`0`|
|更新日時|`Oct 24 19:45`|
|ファイル名|`file1`|

ハードリンクについては今は説明しません．ほとんどの項目については意味はわかりやすいと思いますので，パーミッションの項目についてのみさらに詳しく説明します．
パーミッションは以下のように10文字で表記されます．

|項目|表している事柄|
|---|---|
|1文字目|ファイルの種類|
|2,3,4文字目|所有ユーザの権限|
|5,6,7文字目|所有グループの権限|
|8,9,10文字目|その他のユーザの権限|

ファイルの種類に関してはいろいろなものが考えられますが，ここでは，`-`の場合は通常のファイル，`d`の場合はディレクトリであるということのみ知っておいてください．
また，所有ユーザの権限，所有グループの権限，その他のユーザの権限に関しては，以下の形式で表記されます．

|項目|表している事柄|取りうる値|
|---|---|---|
|1文字目|読み書き権限の有無|`-`または`r`|
|2文字目|書き込み権限の有無|`-`または`w`|
|3文字目|ファイル実行権限の有無|`-`または`x`|

次に，所有ユーザを変更してみましょう．
```
$ sudo chown root file1
```
その後，先ほどと同様にファイルのパーミッションを確認してみます．
```
$ ls -l
```
すると出力は以下のようになっていると思います．
```
total 0
-rw-rw-r-- 1 root minicamp 0 10月 24 20:19 file1
```
所有ユーザが`minicamp`から`root`に変更されました．次に，所有グループも変更してみます．
```
$ sudo chown root:root file1
```
その後，先ほどと同様にファイルのパーミッションを確認してみます．
```
$ ls -l
```
すると出力は以下のようになっていると思います．
```
total 0
-rw-rw-r-- 1 root root 0 10月 24 20:19 file1
```
所有グループが`minicamp`から`root`に変更されました．所有グループは`root`のまま，所有ユーザを`minicamp`に戻します．
```
$ sudo chown minicamp:root file1
```
その後，先ほどと同様にファイルのパーミッションを確認してみます．
```
$ ls -l
```
すると出力は以下のようになっていると思います．
```
total 0
-rw-rw-r-- 1 minicamp root 0 10月 24 20:19 file1
```
ここで，パーミッションのところを見ると，所有ユーザは読み書きができるように設定されていることが分かります．試しに読み書きをしてみましょう．以下のコマンドでファイルに書き込むことができます．
```
$ echo ABC > file1
```
次に，ファイルの内容を表示してみましょう．
```
$ cat file1
```
以下のように表示されるはずです．
```
ABC
```
次に，ファイル所有ユーザの読み取り権限を削除してみます．権限の設定には`chmod`コマンドを使います．
```
$ chmod u=r file1
```
`u=r`は，ファイル所有ユーザの権限を読み取りのみに設定するということを表しています．`=`の前にある`u`は所有ユーザを意味し，同様に`g`は所有グループ，`o`はその他のユーザを意味します．`=`のあとにある`r`は読み取り，`w`は書き込み，`x`は実行を意味しています．
その後，先ほどと同様にファイルのパーミッションを確認してみます．
```
$ ls -l
```
すると出力は以下のようになっていると思います．
```
total 4
-r--rw-r-- 1 minicamp root 4 10月 24 20:26 file1
```
所有ユーザの書き込み権限がなくなったことがわかります．そのため，以下のように書き込みを試みると失敗します．
```
$ echo ABC > file1
```
以下のようにエラーになります．
```
-bash: file1: Permission denied
```
読み取りは問題なくできることも確かめましょう．以下のコマンドでファイルの内容を読み取って表示します．
```
$ cat file1
```
先ほどと同じように，読み取りは問題なく行われ，ファイルの内容が表示されます．
```
ABC
```
`chmod`コマンドの使用例として，所有者にすべての権限を付与し，ほかのユーザは読み取りのみできるように設定してみましょう．以下のコマンドがそれを行います．複数のパーミッションを1回のコマンドで設定する時はカンマ`,`で区切ります．
```
$ chmod u=rwx,go=r file1
```
正しく設定できていることを確認します．
```
$ ls -l
```
以下のように，パーミッションが`-rwxr--r--`となっているはずです．
```
total 4
-rwxr--r-- 1 minicamp root 4 10月 24 20:26 file1
```
最後に，練習に使用したファイルはもう不要なので削除します．
```
$ cd ../
$ rm -R perm
```
## プロセス
### 概要
プロセスは，大まかには動作中の1つのプログラムのことを指します．ソフトウェアを起動したり，コマンドを実行したとき，ほとんどの場合は何らかのファイルが実行されます．ファイルを実行することは新しいプロセスを作成することを意味し，そのプロセスがあなたがやろうとしたことを実際に遂行します．
### プロセスID
ユーザIDやグループIDと同様に，すべてのプロセスも0以上の整数のIDを割り当てられています．これをプロセスID，または省略してPIDと呼ばれることもあります．すべてのプロセスは異なるプロセスIDを持っています．同じファイルを複数回実行した場合も，それぞれ異なるプロセスIDを持ちます．
### 資源の分離
プロセスはそれぞれ，多くのものが分離された環境で動作します．たとえば，開いているファイルや，そのプロセスの使用しているメモリなどが分離されます．他のプロセスのメモリや開いているファイルには基本的にはアクセスできません．
### 実行ユーザ
実行されたプロセスは，そのプロセスを開始したユーザの権限を持ちます．つまり，そのユーザがアクセスできるすべてのファイルにアクセス可能で，そのユーザがアクセスできるすべてのOSの機能を利用できます．
### 実習
現在実行されているプロセスの一覧は以下のコマンドで表示できます．
```
$ ps -a -x
```
たくさんの文字列が表示されると思いますが，最初の2行はおおむね以下のようになっていると思います．
```
    PID TTY      STAT   TIME COMMAND
      1 ?        Ss     0:02 /sbin/init splash
```
これは，プロセスIDが`1`のプロセスは`/sbin/init splash`というコマンドが実行されて開始されたものであるということを意味します．実行ユーザも確認してみましょう．
```
$ ps -a -x -u
```
最初の2行はおおむね以下のようになっていると思います．ここから，プロセスIDが1のプロセスの実行ユーザは`root`であることがわかります．
```
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.1 168744 12844 ?        Ss   16:40   0:02 /sbin/init splash
```
コマンドの末尾に`&`をつけると，バックグラウンドでコマンドを実行することができます．また，`sleep`コマンドはその名前のとおり指定された秒数だけ待つコマンドです．以下のコマンドを入力してみましょう．
```
$ sleep 60 &
```
すると，`sleep`コマンドの実行が開始されたことを示すメッセージが表示されます．
```
[1] 3320
```
そのあとすぐに，以下のコマンドを実行します．
```
$ ps
```
すると，以下のような出力がされると思います．プロセスIDは環境によって異なります．
```
    PID TTY          TIME CMD
   2235 pts/0    00:00:00 bash
   3320 pts/0    00:00:00 sleep
   3321 pts/0    00:00:00 ps
```
先ほど実行した`sleep`コマンドがプロセスID`3320`のプロセスとして実行されていることがわかります．約1分後に，ふたたび以下のコマンドを実行してみます．
```
$ ps
```
すると，以下のように表示されるはずです．
```
    PID TTY          TIME CMD
   2235 pts/0    00:00:00 bash
   3323 pts/0    00:00:00 ps
[1]+  Done                    sleep 60
```
最後の行は，`sleep`コマンドが終了したことを示すメッセージです．プロセス一覧から，`sleep`コマンドのプロセスがなくなっていることが分かります．
## パイプ
### 概要
パイプは，プロセスとプロセスの間で通信するために使われる特殊なファイルです．ある2つのプロセスそれぞれでパイプを開いた上，片方のプロセスがパイプに書き込み別のプロセスがそのパイプから読み出すことで，その2つのプロセスの間で通信することができます．ファイルの一種なので，通常のファイルと同様に読み書きすることができます．
### 無名と名前つき
名前つきのものと無名のものがあります．名前つきのものはファイルとしてどこかに存在し，パスで1つ指定できます．無名のものはプログラムで作成され，内部的に使用されます．
### 一方通行
Linuxでのすべてのパイプは一方通行です．つまり，一つのパイプを利用して双方向通信をすることはできません．双方向通信が必要な場合はパイプを2つ使用します．
### 1対1対応
1つのパイプのパイプにつき，1つのプロセスのみが読み取りをすることができ，1つのプロセスのみが書き込みをすることができます．
### 読み書きの順序
パイプでは，最初に書き込んだものが最初に読み出されます．
### メモリ上に存在
無名・名前つきのどちらのパイプも，読み書きにともなって記憶装置に何かが書き込まれることはありません．すべてOS内部のメモリ上に保存されます．
### 実習
まず，演習のためのディレクトリを作成し，カレントディレクトリをそのディレクトリに変更します．
```
$ mkdir pipe
$ cd pipe
```
次にパイプを作成します．名前つきパイプは以下のコマンドで作成できます．
```
$ mkfifo a
```
ターミナルをもう一つ開きます．どちらか1つのターミナルで次のコマンドを入力します．これはパイプに文字列を書き込むコマンドです．
```
$ echo ABC > a
```
このコマンドはすぐには終了せず，実行中のままになります．
もう一つのターミナルで，次のコマンドを入力します．
```
$ cat a
```
すると，このコマンドの実行は即座に終了し，後者のコマンドを入力したターミナルで，以下のように出力されるでしょう．このコマンドが終了すると，初めに入力したコマンドも終了します．
```
ABC
```
これは2つのターミナルのそれぞれのコマンドのプロセスの間で通信ができたことを表しています．最初に入力した`echo`コマンドがすぐに終了しなかったのは，パイプの読み取りをするプロセスが無かったために書き込みが完了しなかったからです．
新しく開いたターミナルはもう使用しないので閉じてかまいません．最後に演習用ディレクトリを削除します．
```
$ cd ../
$ rm -R pipe
```
## シグナル
### 概要
シグナルは，プロセスからプロセスに定型的なメッセージを送るための機能です．主にプロセスの状態を変化させるために使用します．あるプロセスは別のプロセスにシグナルを送信することで，そのプロセスを終了させたりすることができます．
### 種類
シグナルには多くの種類があります．それぞれに対し，プログラムはシグナルを受け取った時の動作を設定することができます．とくに設定されていない場合には，既定の動作が実行されます．
### 権限
シグナルを送信するユーザがシグナルの送信先のプロセスと同一のユーザである場合のみ，シグナルを送信できます．例外的にrootユーザはすべてのプロセスにシグナルを送信することができます．
### 実習
`SIGKILL`シグナルを受信したプロセスは終了します．これを試してみます．まず，`sleep`コマンドをバックグラウンドで実行します．
```
$ sleep 3600 &
```
すると，実行が開始されたことを示すメッセージが表示されます．
```
[1] 3846
```
`ps`コマンドで，`sleep`コマンドのプロセスが実行されていることを確認しましょう．
```
$ ps
```
すると，以下のように`sleep`コマンドのプロセスが実行されていることが確認できます．
```
    PID TTY          TIME CMD
   2235 pts/0    00:00:00 bash
   3846 pts/0    00:00:00 sleep
   3847 pts/0    00:00:00 ps
```
この場合，実行中の`sleep`コマンドのプロセスのプロセスIDは`3846`です．
このプロセスに`SIGKILL`シグナルを送信してみましょう．`kill`コマンドは指定したプロセスにシグナルを送信するコマンドです．以下のように`-s SIGKILL`オプションを指定すると，`SIGKILL`シグナルを送信することができます．その後にプロセスIDを入力し，実行します．
プロセスIDは環境によって違うため，先ほど`ps`コマンドで表示されたものを使用してください．
```
$ kill -s SIGKILL 3846
```
その後，再び`ps`コマンドでプロセス一覧を表示します．すると，プロセス一覧から先ほどのプロセスIDが`3846`のプロセスがなくなっていることが確認できます．さらに，最後の行にはプロセスが`SIGKILL`シグナルによって終了した旨のメッセージが表示されます．
```
    PID TTY          TIME CMD
   2235 pts/0    00:00:00 bash
   3851 pts/0    00:00:00 ps
[1]+  Killed                  sleep 3600
```
