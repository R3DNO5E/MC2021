# Linuxシステムプログラミング入門 事前学習#4.1 LinuxでのC言語の基礎
## 16進数について
以下，値の表記に16進数を用いることがあります．16進数での表記をするときは，数字の頭に`0x`をつけて表記します．たとえば，10進数で20は16進数で表記すると14になるので，表記するときは`0x14`となります．
## ポインタについて
ポインタは，変数がどこに記録されているかの位置を表す値です．
### アドレスとの対応
ポインタは，Cの規格ではある値の場所を示す値というように抽象的にしか定められておらず，その値自体に意味を持たせてはいませんが，Linux上でのgccを含む多くの実装では，ポインタの値はメモリ上のアドレスです．
このアドレスというのは，実際のメモリチップ上でのアドレスではなく，OSによって割り当てられた仮想的なメモリアドレスで，CPUのMMUという機能によって実際のメモリチップ上のアドレスに対応付けられています．
### Cでの表記
変数からその変数のポインタを取得するには，変数の頭に`&`をつけます．ポインタからそのポインタの指す変数の値を取得するには，ポインタの頭に`*`をつけます．
```
int a = 123;
int *a_ptr = &a;
int b = *a_ptr;
// b is 123
```
## 配列について
配列を宣言すると，メモリ上にその型の領域の連続が確保されます．配列型の値は，その領域の先頭のアドレスです．
たとえば，`int`型の配列`int arr[3]`を宣言した場合を考えてみます．`int`型のサイズが2バイトのシステムでは以下のようなメモリが確保されます．arrの値が`0x1234`であるとします．
```
+---------------+---------------+----------------+
|Memory Address | Array Content |Pointer Notation|
+---------------+---------------+----------------+
|    0x1234     |               |     arr        |
+---------------+    arr[0]     |----------------+
|    0x1235     |               |                |
+---------------+---------------+----------------+
|    0x1236     |               |     arr+1      |
+---------------+    arr[1]     |----------------+
|    0x1237     |               |                |
+---------------+---------------+----------------+
|    0x1238     |               |     arr+2      |
+---------------+    arr[2]     |----------------+
|    0x1239     |               |                |
+---------------+---------------+----------------+
```
つまり，メモリ上のアドレス`0x1234`から`0x1239`にかけてのメモリが6バイト確保され，`arr[0]`の値は`0x1234`と`0x1235`の2バイトにかけて記録されます．ポインタの操作では，1バイトごとではなくそのポインタの指す値の型のサイズごと，つまりこの場合は`int`型で2バイトごととなるので，arr+1のアドレスは`0x1234`+`0x2`=`0x1236`となります．
## 文字列について
文字は，`char`型で表されます．各文字はASCIIコードなどの表にしたがって，0以上の整数に割り当てられていて，`char`型の変数の値はこの整数です．たとえば`'A'`という文字は`65`，16進数で書くと`0x41`です．
そのため，たとえば以下のような`if`文は真となります．
```
if('A' == 0x41){
    // do something
}
```
文字列を扱いたい場合には，`char[]`など，メモリ上の連続した領域に前から順に文字を格納します．文字列といった場合，ほとんどは表現したい文字列の末尾にヌル文字という特殊な文字を記録します．これはCでは`'\0'`と表され，値は`0`です．文字列リテラルは，このような文字列の先頭のアドレスを指すポインタとして扱えます．
例として，`"Hello"`という文字列の場合を考えてみます．`char *s = "Hello";`というコードがあった場合，`s`のアドレスには`'H'`という文字が記録されています．`s`のアドレスが`0x1234`であったとすると，メモリの様子は以下のようになります．
```
+----------+-------+---------+
| Address  |  Char |  Value  |
+----------+-------+---------+
|  0x1234  |  'H'  |  0x48   |
+----------+-------+---------+
|  0x1235  |  'e'  |  0x65   |
+----------+-------+---------+
|  0x1236  |  'l'  |  0x6c   |
+----------+-------+---------+
|  0x1237  |  'l'  |  0x6c   |
+----------+-------+---------+
|  0x1238  |  'o'  |  0x6f   |
+----------+-------+---------+
|  0x1239  |  '\0' |  0x00   |
+----------+-------+---------+
```
よって，以下のような`if`文は真となります．
```
if(*(s+1) == 0x65){
    // do something
}
```
## ファイルについて
Linuxでは，通常のファイルはバイトの連続した列です．
Linuxのシステムコールでは，ファイルを読み書きするとき，以下の手順をとります．
1. ファイルを開く
2. 読み書きを行う
3. ファイルを閉じる

読み書きをする前にはかならずファイルを開く必要があり，ファイルを閉じた後にふたたび読み書きするにはもう一度ファイルを開く必要があります．
### オフセットとは
開いたファイルには，オフセットという値があります．これは，次にファイルから読み出ししたときに，ファイルの冒頭からその値ぶん後のバイト列が読み出されるということです．または，書き込んだときにファイルの冒頭からその値ぶん後の位置に書き込まれるということです．
ファイルの冒頭読み書きは複数回連続して行うことができます．読み書きするたびに，読み込みまたは書き込んだぶんだけファイルオフセットは増加していきます．`"Hello"`と記録されたファイルを開き，1回めに2バイト読み出すと`"He"`が読み出され，続けて2バイト読み出すと`"ll"`が読み出されます．
### ファイルを開く
ファイルを開くには，`open`システムコールを用います．
```
int open(const char *pathname, int flags);
```
第一引数の`pathname`には開きたいファイルの絶対パスまたは相対パス，第二引数には開くときの動作を既定するフラグを渡します．フラグにはいろいろなものがありますが，以下に挙げた基本的な三つの中から1つを利用する必要があります．

|フラグ|意味|
|---|---|
|`O_RDONLY`|ファイルを読み取り専用で開く|
|`O_WRONLY`|ファイルを書き込み専用で開く|
|`O_RDWR`|ファイルを読み書きができるように開く|

正常にファイルを開くことができた場合，返り値はファイルディスクリプタと呼ばれる0以上の整数になります．ファイルディスクリプタは開いたファイルを読み書きしたり閉じたりするときに利用します．
ファイルを開くのに失敗した場合，-1が返ります．
### 読み込み
ファイルから読み取るには，`read`システムコールを用います．
```
ssize_t read(int fd, void *buf, size_t count);
```
第一引数の`fd`にはファイルを開いたときに得たファイルディスクリプタ，第二引数の`buf`には読み取ったデータを保存するためのメモリ領域のポインタ，第三引数の`count`にはそのメモリ領域のバイト単位での大きさを指定します．
正常にファイルを読み取ることができた場合，返り値は読み取ったデータのバイト数になります．0である可能性もあります．読み取りでエラーが発生して失敗した時は，-1が返ります．
### 書き込み
ファイルへ書き込むには，`write`システムコールを用います．
```
ssize_t write(int fd, const void *buf, size_t count);
```
第一引数の`fd`にはファイルを開いたときに得たファイルディスクリプタ，第二引数の`buf`にはファイルに書き込むデータが保存されたメモリ領域のポインタ，第三引数の`count`にはそのメモリ領域のバイト単位での大きさを指定します．
正常にファイルに書き込むことができた場合，返り値は書き込んだデータのバイト数になります．書き込みでエラーが発生して失敗した時は，-1が返ります．
### ファイルを閉じる
ファイルを閉じるには，`close`システムコールを用います．
```
int close(int fd);
```
引数の`fd`にはファイルを開いたときに得たファイルディスクリプタを指定します．
正常にファイルを閉じることができた場合，0が返ります．失敗した場合，-1が返ります．
## 標準入出力について
Cには，標準入出力というものがあります．これは，コンソールからプログラムを実行したときに，文字を入力してプログラムから読み取ったり，またプログラムから出力して文字を表示するために利用するものです．
### 種類
標準入出力には以下の種類があります．
* 標準入力
* 標準出力
* 標準エラー出力
### 利用例
よく知られた`printf`関数は標準出力に文字列を書き込むものです．また，同様によく知られた`scanf`関数は標準入力から文字列を読み込むものです．
### 読み書き
標準入出力に書き込むには，ファイルの項で説明した`read`システムコールまたは`write`システムコールを用います．
標準入出力はファイルと同じように読み書きできますが，プログラムが開始されたときに自動的に開かれており，`open`システムコールを使用しなくても読み書きすることができます．使用するファイルディスクリプタは予め決まっています．

|種類|ファイルディスクリプタの値|
|---|---|
|標準入力|`0`|
|標準出力|`1`|
|標準エラー出力|`2`|

これらをよりわかりやすく扱うため，`unistd.h`というインクルードファイルで，以下のマクロが定義されています．
```
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2
```
